<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c7{-webkit-text-decoration-skip:none;color:#000000;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c8{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c13{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c5{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c11{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c12{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c14{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c16{color:inherit;text-decoration:inherit}.c3{height:11pt}.c10{text-indent:36pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c14 doc-content"><p class="c2 title" id="h.adi6xpgcm1ml"><span class="c15">CS 184: Computer Graphics and Imaging, Spring 2024</span></p><h1 class="c13" id="h.iouifddb7n2l"><span class="c6">Project 2: Mesh Edit</span></h1><h2 class="c11" id="h.92vdcun1ct1q"><span class="c9">Srikar Talluri</span></h2><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><h1 class="c8" id="h.ev74p7y40tu8"><span class="c6">Overview</span></h1><p class="c0 c3"><span class="c1"></span></p><p class="c0 c10"><span class="c1">This homework was an involved and hands-on approach into the world of bezier curves and meshes. This homework was an involved and hands-on approach into the world of rasterization. Through building up basics such as parametrizing a Bezier curve, modeling out a Bezier surface, and coloring in vertex normals, I was able to actually practice and implement myself the things I have learned and reviewed in lectures. And through the use of the GUI, I was able to physically see the effects of such techniques being able to smooth out the surface using Phong Shading. The latter half of the homework dived into some advanced topics such as methods of flipping an edge between two triangles, splitting an edge to create 2 or 4 more triangles, and ultimately being able to upsample my mesh to be more complex. Probably the most interesting takeaway for me is the meticulous focus that was required to to implement some of the problems. The bulk of my problems that required debugging were focused in parts 5 and 6. Many lost or unassigned pointers resulted in the mesh not being able to render. However, what made implementing and debugging much easier was actually drawing out the diagrams of flipping, splitting, or subdividing edges. Being able to sketch out my ideas, while also being able to programmatically transfer them to my mesh was one of the most rewarding parts of the homework.</span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><h1 class="c8" id="h.f6qxjizg6ejj"><span class="c6">Section I: Bezier Curves and Surfaces</span></h1><p class="c0 c3"><span class="c1"></span></p><h2 class="c5" id="h.8hs9k6x90fw0"><span class="c9">Part 1: Bezier Curves with 1D de Casteljau Subdivision</span></h2><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Briefly explain de Casteljau&#39;s algorithm and how you implemented it in order to evaluate Bezier curves.</span></p><p class="c0"><span class="c1">de Casteljau&#39;s algorithm provides an efficient way to draw Bezier curves. It uses a recursive method to evaluate a point p in relation to a parameter t that varies from 0 to 1. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">The way I implemented it is as follows.</span></p><p class="c0"><span class="c1">The input is a list of vectors. To evaluate a singular step, I must lerp each adjacent pair of Vectors with respect to a class parameter t. Since my output list&rsquo;s length will be exactly one less than the input list, I iterate through the first n-1 indices of the input list. At each iteration, I take the current and next vector and lerp them using a custom-made lerp2D function. I then store this lerp&rsquo;d value in the output array.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 564.50px; height: 398.04px;"><img alt="" src="images/image34.png" style="width: 564.50px; height: 398.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 567.50px; height: 413.80px;"><img alt="" src="images/image30.png" style="width: 567.50px; height: 413.80px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c7">Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press E to step through. Toggle C to show the completed Bezier curve as well.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Level 0</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 365.33px;"><img alt="" src="images/image27.png" style="width: 624.00px; height: 365.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Level 1</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 538.50px; height: 317.58px;"><img alt="" src="images/image19.png" style="width: 538.50px; height: 317.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Level 2</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 326.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 326.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Level 3</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 324.00px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 324.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Level 4</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 317.33px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 317.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Level 5:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 269.33px;"><img alt="" src="images/image23.png" style="width: 624.00px; height: 269.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Completed Curve:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 297.33px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 297.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter via mouse scrolling.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 526.50px; height: 357.75px;"><img alt="" src="images/image26.png" style="width: 526.50px; height: 357.75px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 550.50px; height: 373.18px;"><img alt="" src="images/image8.png" style="width: 550.50px; height: 373.18px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><h2 class="c5" id="h.bybekpy4bbn8"><span class="c9">Part 2: Bezier Surfaces with Separable 1D de Casteljau</span></h2><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">The de Casteljau algorithm can easily be extended to Bezier surfaces as it is simply adding another dimension. In the linear model, a singular parameter t controls where along the curve the interpolated point falls. In the surface model, there exist two parameters u and v that control where a certain point falls on the calculated surface. Naturally, the input of control points will now be a matrix of dimensions m x n (n x n in our case for simplicity&rsquo;s sake). </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">The way it was implemented in my project was broken down into 3 functions:</span></p><p class="c0"><span class="c1">evaluateStep(vector points, double t): This essentially is the same as part 1 but using a 3D vector instead of a 2D one. It performs a singular step of calculating the Bezier Curve.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Evaluate1D(vector points, double t): A natural extension of the previous function, this function fully computes all of the steps until there is only one output. This allows us to fully calculate the correct interpolated value along a certain axis at a certain parameter level (either u or v).</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">evaluate(vector&lt;vector&lt;Vector3D&gt;&gt; points, double u, double v): This is the entire evaluation function of the Bezier surface. For every row, we fully evaluate using the previous function the interpolated value at the given u level. This means for every row we generate one point, resulting in n points, which will then be our input control points for the following step. I then inputted these control points into one more evaluate1D call but this time using the parameter v to control how far the point lies along the v axis. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 421.33px;"><img alt="" src="images/image17.png" style="width: 624.00px; height: 421.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><h1 class="c8" id="h.ionzv83xbq4c"><span class="c6">Section II: Triangle Meshes and Half-Edge Data Structure</span></h1><p class="c0 c3"><span class="c1"></span></p><h2 class="c5" id="h.y615hsyykirq"><span class="c9">Part 3: Area-Weighted Vertex Normals</span></h2><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Briefly explain how you implemented the area-weighted vertex normals.</span></p><p class="c0"><span class="c1">By using a standard iterating algorithm for looping through a given vertex&rsquo;s incident faces, I was able to sum up the normal vectors of each face around a vertex. I made sure to not include the boundary faces, in the case that the mesh has boundaries. I then used the in-built Vector::normalize function to make the total vector a unit vector and then returned this value.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use Q to toggle default flat shading and Phong shading.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Without Vertex Normals:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 352.00px;"><img alt="" src="images/image36.png" style="width: 624.00px; height: 352.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">With Vertex Normals</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 357.33px;"><img alt="" src="images/image31.png" style="width: 624.00px; height: 357.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><h2 class="c5" id="h.l0jvdw86ts4q"><span class="c9">Part 4: Edge Flip</span></h2><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c0"><span class="c1">Before rushing into the implementation of the edge flip, I made sure to fully diagram out all of the components related to flipping an edge. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 176.00px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 176.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">There exist other ways to flip but I chose this one as it seemed the most intuitive to me. The flip mechanism intuition essentially boils down to the edge bc being turned counterclockwise 90 degrees, allowing the halfedge to keep most of the same pointers. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 472.50px; height: 317.05px;"><img alt="" src="images/image11.png" style="width: 472.50px; height: 317.05px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">The beginning of the code consisted of getting all the related pointers. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">The main core chunk of the logic consisted of reassigning the pointers of bd and ac to reflect their different face pointers as well as many of the half edges getting assigned with different pointers for their next element. For example the old pointer representing the Halfedge from b to c would now be the next element of bd rather than ab. Through a series of these reassignments, I was able to flip the edge successfully. Notice that the actual Edge element does not get affected throughout the entire computation as the Halfedges associated with it do not functionally change. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Show screenshots of the teapot before and after some edge flips.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Before</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 476.50px; height: 332.60px;"><img alt="" src="images/image4.png" style="width: 476.50px; height: 332.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">After</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 417.33px;"><img alt="" src="images/image38.png" style="width: 624.00px; height: 417.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c0"><span class="c1">No Debugging Journey for this subproblem. It was very helpful to draw the diagram first. </span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><h2 class="c5" id="h.oa3s3ef8sbau"><span class="c9">Part 5: Edge Split</span></h2><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c0"><span class="c1">Similar to the previous section, I made sure to fully draw out the diagram before rushing into implementation:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 180.00px;"><img alt="" src="images/image20.png" style="width: 624.00px; height: 180.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">It can be seen that the following new objects have to be created:</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Face amc, cmd, dmb, bma;</span></p><p class="c0"><span class="c1">Edge am_e, bm_e, cm_e, dm_e; &nbsp;(xm_e simply means the edge object between x and m)</span></p><p class="c0"><span class="c1">Halfedge am, ma, bm, mb, cm, mc, dm, md (xy means halfedge from x to y)</span></p><p class="c0"><span class="c1">Vertex m</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Similarly it can be seen that the following need to be deleted:</span></p><p class="c0"><span class="c1">Face abc, cbd</span></p><p class="c0"><span class="c1">Edge bc</span></p><p class="c0"><span class="c1">Halfedge bc, cb</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">To ensure I save on memory as well as ensure no incorrect iteration problems occur for part 6, I reused some of the &ldquo;deleted&rdquo; elements and simply reassigned them to the elements that needed to be created. For example I arbitrarily decided that Edge bc will now become Edge cm_e. Or the halfedge cb now becomes the halfedge cm (This last one actually becomes necessary for boundary edges).</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Show screenshots of a mesh before and after some edge splits.</span></p><p class="c0"><span class="c1">Before</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 511.48px; height: 351.71px;"><img alt="" src="images/image32.png" style="width: 511.48px; height: 351.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">After</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 517.50px; height: 403.63px;"><img alt="" src="images/image28.png" style="width: 517.50px; height: 403.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Show screenshots of a mesh before and after a combination of both edge splits and edge flips.</span></p><p class="c0"><span class="c1">Before:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 550.50px; height: 384.64px;"><img alt="" src="images/image6.png" style="width: 550.50px; height: 384.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">After: (red are edge splits blue are edge flips)</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 544.15px; height: 382.50px;"><img alt="" src="images/image10.png" style="width: 544.15px; height: 382.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c7">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c0"><span class="c1">The main debugging that had to be done in this section came when I was trying to implement support for boundary edges. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 241.00px; height: 165.00px;"><img alt="" src="images/image7.png" style="width: 241.00px; height: 165.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Take into consideration this case. Let&rsquo;s assume that we are trying to split the edge associated with h&rsquo;. Before I was simply deleting the halfedge h&rsquo; and instantiating two new Halfedges in its place. While this worked for no boundaries, it failed to properly work for boundary edges.</span></p><p class="c0"><span class="c1">This is because the h&rsquo;&rsquo;s previous (or the thing that points into h&rsquo;) which also lies on the boundary has a pointer in its next field to h&rsquo;. Problematically, deleting h&rsquo; will be this pointer is now garbage. To get around this, instead of deleting h&rsquo;, I made it cm. This is because cm is the correct next for the aforementioned previous boundary step.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.</span></p><p class="c0"><span class="c1">In Beetle.dae</span></p><p class="c0"><span class="c1">Before:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 510.76px; height: 333.92px;"><img alt="" src="images/image9.png" style="width: 510.76px; height: 333.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">After:</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 531.24px; height: 346.50px;"><img alt="" src="images/image33.png" style="width: 531.24px; height: 346.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><hr style="page-break-before:always;display:none;"></p><h2 class="c5" id="h.opno90x3vcw7"><span class="c9">Part 6: Loop Subdivision for Mesh Upsampling</span></h2><p class="c0"><span class="c7">Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c0"><span class="c1">To implement loop subdivision, I followed a general procedure outlined in the spec. To do this, I first computed the new positions for every vertex by following the given weights. In order to ensure all newpositions get updated at the same time (meaning the new positions are only dependent on the surrounding vertices old positions), I made use of the vertex&rarr;newPositon field. Any computation was stored in this field.</span></p><p class="c0"><span class="c1">Similarly, for each of the edges, I computed a newPosition that represents the position of the vertex that gets created if that edge were to get split. I stored that in the edge&rarr;newPosition field. Intuitively storing it in the edge makes sense as the new vertex has not been created yet and every new vertex gets created along an edge (from an edge split).</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">I then split all the edges. This was a little bit tricky as we had to only split the original edges, and an iteration through all edges would iterate through the newly created edges, creating a never ending loop. As such, I created a new field in the Edge class called alrSplit which represents if the edge has already been split or is a product of a split. Graphically, edges am, bm, cm, dm will all have the alrSplit as true. But ab, bd, dc, ca will all have alrSplit as false. This ensures that we split every edge only once.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Then we flip every edge that connects an old vertex to a new vertex. However, we should not flip edges that make up an original edge. Graphically, we should not be splitting edges bm, and cm. As such, when splitting I made use of the vertex&rarr;isNew flag, setting bm and cm to false and am and dm to true. Thus in this step, I checked for both the vertex condition (one old and one new Vertex) as well as the Edge being part of a new edge. Moreover, to support multiple levels of subdivision, I set both the alrSplit and isNew fields of every Vertex and Edge to false at the beginning of loop subdivision during the computation of vertex and edge positions.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Finally we copy the vertex newPositions into their positions to update where they actually get rendered.</span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?</span></p><p class="c0"><span class="c1">As a whole loop subdivision, aims to smooth out a mesh, making it more rounded and &ldquo;flowy&rdquo;. However, this has an adverse effect on sharp edges and corners as it makes them more rounded even when it may not be desired. With every loop, the sharp corners and edges become less and less pronounced. This is because the loop subdivision algorithm, especially one without boundaries, averages all the vertices around it when calculating the new position of a vertex. This naturally diminishes the sharpness of various corners and edges. We can reduce this by adding more splits along the edges, to increase the &ldquo;importance&rdquo; or weights of the points on the edge.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 512.66px; height: 433.15px;"><img alt="" src="images/image24.png" style="width: 512.66px; height: 433.15px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">A simple preprocess of the cube such as this (split each physical cube edge a couple of times) results in significantly sharper edges than no preprocessing. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 488.50px; height: 371.21px;"><img alt="" src="images/image35.png" style="width: 488.50px; height: 371.21px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c7"></span></p><p class="c0"><span class="c7">Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 437.67px; height: 361.92px;"><img alt="" src="images/image15.png" style="width: 437.67px; height: 361.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span>It can be seen that the initial mesh of the cube splits each square face of the cube into two triangles. Problematically, this results in slightly different newPosition coordinates for each vertex, because some edges have only degree 3 while others have degree 6, resulting in some vertices having been averaged out with more other vertices. This would result in the high degree vertices being smoothed out more than the low degree ones. It is reasonable to assume that making a symmetric initial mesh would result in a symmetric divided mesh.</span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">A simple subdivision such as this: (splitting the diagonal edge on every face)</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 436.50px; height: 368.65px;"><img alt="" src="images/image2.png" style="width: 436.50px; height: 368.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Results in a much more symmetric divided mesh after two iterations:</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 457.50px; height: 336.53px;"><img alt="" src="images/image16.png" style="width: 457.50px; height: 336.53px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c7">If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c12">Loop Subdivision with Boundary Edges</span><span class="c1">:</span></p><p class="c0"><span class="c1">To support boundary edges, there were changes to the calculations for both the vertex and edge new positions</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 557.50px; height: 322.53px;"><img alt="" src="images/image21.png" style="width: 557.50px; height: 322.53px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">For edge computations, instead of doing a &#8540;, &#8540;, &#8539;, &#8539; split I instead opted for a &frac12;, &frac12; split between c and b. This is because I want the point m to still lie on the boundary rather than moving more toward a, which might end up creating a jagged edge. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Similarly for v, I only considered the vertices adjacent to it that also lie on the boundary. (In this case, x and y). I used the formula:</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">v&rarr;newPosition = &#8539; (x&rarr;position + y&rarr;position) + &frac34; (v&rarr;positon)</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span>This is as outlined in the paper </span><span class="c4"><a class="c16" href="https://www.google.com/url?q=https://mrl.cs.nyu.edu/~dzorin/papers/boiermartin2005sbt.pdf&amp;sa=D&amp;source=editors&amp;ust=1709146004046402&amp;usg=AOvVaw1UAg4yaGo2_soXO_Bpif72">A Survey of Subdivision-Based Tools for Surface Modeling</a></span><span class="c1">&nbsp;by Ioana Boier-Martin, Denis Zorin, and Fausto Bernardini. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span>The before and after of the beetle.dae </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 558.50px; height: 361.32px;"><img alt="" src="images/image22.png" style="width: 558.50px; height: 361.32px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 645.99px; height: 417.68px;"><img alt="" src="images/image37.png" style="width: 645.99px; height: 417.68px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Sqrt 3: Subdivision:</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">I also implemented sqrt3 subdivision.</span></p><p class="c0"><span class="c1">This was done in 3 steps.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">First was implementing a flag in every face called isNew. This represents if the face is a new face created in the process of centroid subdivision.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Second was physically splitting the triangle into 3 parts.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 463.50px; height: 305.29px;"><img alt="" src="images/image29.png" style="width: 463.50px; height: 305.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c1">Referring to this diagram, we can see that 3 new faces, 6 new Halfedges, 3 new edges, and 1 new vertex must be created. However, the deletion of the face abc results in only 2 newly created faces with reassignment. </span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">During every subdivision, I also made sure to set the isNew flag of the edges ab, bc, and ca to be false and am_e, bm_e, and cm_e to be true.</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Third and finally, I made flipped every not new edge (old edge)</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Here is the output of my code on the icosahedron</span></p><p class="c0 c3"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">Before subdivision</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.50px; height: 315.36px;"><img alt="" src="images/image18.png" style="width: 432.50px; height: 315.36px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">After 1 iteration:</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 541.50px; height: 439.97px;"><img alt="" src="images/image25.png" style="width: 541.50px; height: 439.97px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">After 2 iterations</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 511.00px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 511.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">It can be seen that after two iterations, the edges line up with the original mesh. This is because applying the sqrt3 division twice leads to a 1-to-9 refinement of the original mesh, as per the spec. </span></p></body></html>